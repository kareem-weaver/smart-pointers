Smart Pointers
==============

```
  _________                      __                 
 /   _____/ _____ _____ ________/  |_               
 \_____  \ /     \\__  \\_  __ \   __\              
 /        \  Y Y  \/ __ \|  | \/|  |                
/_______  /__|_|  (____  /__|   |__|                
        \/      \/     \/                           
__________      .__        __                       
\______   \____ |__| _____/  |_  ___________  ______
 |     ___/  _ \|  |/    \   __\/ __ \_  __ \/  ___/
 |    |  (  <_> )  |   |  \  | \  ___/|  | \/\___ \ 
 |____|   \____/|__|___|  /__|  \___  >__|  /____  >
                        \/          \/           \/ 
                             \/            
```

Overview
--------
The Smart-Pointers library tracks references to program resources and automates
the freeing of those resources if and only if the reference count drops to zero.
Most commonly, the reference is a pointer and the resource is memory.  In that
context, Smart-Pointers help to prevent memory leaks and dangling pointers, which
commonly causes programs to crash due to memory limitations or segmentation faults, 
respectively.

To use Smart-Pointers, define a non-abstract derived type that 

1. Extends Smart Pointer's `sp_smart_pointer_t` type,
2. Implements the inherited `free` deferred binding, and
3. Invokes the inherited `start_count` procedure inside object constructors.

You can then use intrinsic assignments to copy instances of a `sp_smart_pointer_t`
child type, resulting in a [shallow copy] with the advantage that the target
will be finalized only when it becomes safe to do so.  

Example
-------
See the [example](./example) folder for a demonstration of the use of Smart-Pointers.

Background
----------

For more background on the design philosophy and the internal mechanics of Reference
Counter, see Rouson et al. (see [[1]], [[2]], [[3]]).  This repository's code
originated from refactoring the code in those publications to use more descriptive
more up-to-date coding conventions.  For example, this repository separates interface
bodies into modules and procedure definitions into submodules. This repository also
uses more descriptive nomenclature for the types and procedures.

This repository also adds
1. A [Fortran Package Manager] build system,
2. Tests based on the [Veggies] unit-testing framework,
3. Documentation generated by [`ford`] and deployed to the web via GitHub Actions, and
4. Quality control via continuous integration testing using GitHub Actions.

Supported Compilers
-------------------
Correct execution of the Reference Counter library code requires comprehensive
compiler support for Fortran's type finalization semantics.  The unit test suite
includes compiler standard-conformance tests that include a test for each scenario
in which the Fortran 2018 standard requires that an object be finalized.
The table below summarizes the observed compiler behaviors:

| _Compiler_   | _Test failures_      | _Version tested_                                    |
| :---         |       :---:          | :---                                                |
| NAG          |         0            | `nagfor` 7.1 Build 7113                             |
| Intel        |         2            | `ifort` 2021.5.0 Build 20211109\_000000             |
| Cray         |         3            | `ftn` 13.0.1                                        |
| GCC          |         6            | `gfortran` 12.2.0                                   |
| NVIDIA       | Fails to build (ICE) | `nvfortran` 2022.2                                  |
| AMD          | Fails to build (ICE) | `flang` 13.0.0 (AOCC_3.2.0-Build\#128 2021\_11\_12) |

See the [test suite README.md](./test/README.md) for more details on each compiler's test
failures.

Downloading, Building, and Testing
----------------------------------
On Linux, macOS, or Windows Subsystem for Linux, download, build, and test with
the following shell commands:
```
git clone https://github.com/sourceryinstitute/smart-pointer
cd smart-pointer
```
followed by one of the commands below corresponding to your compiler choice.

### Numerical Algorithms Group (`nagfor`)
```
fpm test --compiler nagfor --flag -fpp
```

### GCC (`gfortran`)
```
fpm test
```

### Intel (`ifort`)
```
fpm test --compiler ifort --flag -coarray=shared
```

### NVIDIA (`nvfortran`)
```
fpm test --compiler nvfortran --flag -Mpreprocess
```

### AMD (`flang`)
```
fpm test --compiler flang --flag -cpp
```

Documentation
-------------
See [Reference Counter's GitHub Pages site] for HTML documentation generated with [`ford`].
See the [doc/] subdirectory for a [PlantUML] script that generates the Unified Modeling Langauge (UML) 
class diagram below of the three derived types in reference-counter.

[1]: https://doi.org/10.1016/j.procs.2010.04.166
[2]: https://doi.org/10.1017/cbo9780511977381 
[3]: https://doi.org/10.1109/MCSE.2012.33
[Fortran Package Manager]: https://github.com/fortran-lang/fpm
[Vegetables]: https://gitlab.com/everythingfunctional/vegetables
[`ford`]: https://github.com/Fortran-FOSS-Programmers/ford
[Reference Counter's GitHub Pages site]: https://sourceryinstitute.github.io/reference-counter
[Atom]: https://atom.io
[PlantUML]: https://plantuml.com
[doc/]: ./doc
[shallow copy]: https://en.wikipedia.org/wiki/Object_copying#Shallow_copy
